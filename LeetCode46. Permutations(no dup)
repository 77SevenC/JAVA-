/*
北逼小白瞎比bi：
解题步骤：
input: an int[] array
problem: find all possible permutations with the elements in the array 排列组合问题
output: List<List<Integer>>

solution: dfs method
high level:
fix one position (e.g., position 0), swap the rest of the element (in the array/list) to that position, to find all the possible 
permuation start from that position 

eg.recursion tree (图没有画完)
    position:                    0        1         2
                                {1}      {2}       {3} 
                             /            |          \
    position0              (1)23        (2)13       (3)12       3 choices
                         /      \
    position1           1(2)3  1(3)2                            2 choices
                        |       |
    position2         12(3)     13(2)                           1 choice 
      
time: O(n!), space O(n)

这道题的一个考点就是要把int[] array转化成为一个list<Integer>, 然后在List<Integer> 
这里边做swap，因为是对整个list做swap，所以就需要Collections.swap() 自带方程
这道题就不是一个string里面做swap， 如果是string 那就是简单的swap function
- int[]{1,2,3}
- list {1},{2},{3}

*/

class Solution {
    public List<List<Integer>> permute(int[] nums) {
        //assum no duplication 
        //corner case check 
        List<List<Integer>> res = new ArrayList<>();
        if(nums == null || nums.length == 0){
            return res;
        }
        //把int[] nums 转化成为一个List<Integer>
        List<Integer> list = new ArrayList<>();
        for(int m : nums){
            list.add(m);
        }
        int n = nums.length;
        //dfs
        dfs(n, 0, list, res);
        
        //return
        return res;
    }
    private void dfs(int n,  int index, List<Integer> list, List<List<Integer>> res){
        //base case check, dfs exit
        if(index == n){
            res.add(new ArrayList<>(list));
            return;
        }
        //dfs induction rule: swap & swap
        for(int i = index; i < n; i++){//0
            Collections.swap(list, i, index);//因为是对list里面的元素进行swap，所以要Collections.swap
            dfs(n, index + 1, list,  res);    
            Collections.swap(list, i, index);
        }       
    }
}

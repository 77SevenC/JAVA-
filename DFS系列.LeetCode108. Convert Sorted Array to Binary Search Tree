/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
/*
åŒ—é€¼å°ç™½çžŽæ¯”biï¼šè§£é¢˜steps
1. clarification:
input: sorted array (in-order)
problem: convert it to a height balanced BST
output: a tree, TreeNode root

BST property: in-order 
Balanced tree property: same height for left and right subtrees

2.solution: use recursion to construct the tree
P.S: å»ºæ ‘ðŸŒ²çš„é‡ç‚¹æ˜¯1ï¼‰æ‰¾root 2ï¼‰æ‰¾å·¦å³å­©å­çš„ä¸ªæ•°å’Œvalueåˆ†åˆ«æ˜¯ä»€ä¹ˆ æ–¹å¯å»ºðŸŒ²
step1: find the root of this balanced tree 
-æ ¹æ®æ€§è´¨ mid of the nums is the root

step2: construct root.left

step3: construct root.right

step4: return root;

time: O(n)
- find the mid O(1)
- construct left sub + right sub O(n)

space: O(n), while O(logN)recursion äº†è¿™ä¸ªtreeï¼Œbutæ€»ä½“æ˜¯O(n),

*/
class Solution {
    public TreeNode sortedArrayToBST(int[] nums) {
        //base case check 
        return construct(nums, 0, nums.length - 1);   
    }
    private TreeNode construct(int[]nums, int left, int right){
       //ä¸èƒ½æ˜¯left>=rightï¼Œå› ä¸ºleft==rightå¯ä»¥æˆç«‹,æ¯”å¦‚æ˜¯åªæœ‰rootçš„æ—¶å€™
        if(left > right){
            return null;
        }
        //find the mid == TreeNode root
        int mid = left + (right - left) / 2;
        TreeNode root = new TreeNode(nums[mid]);
        root.left = construct(nums, left, mid - 1);
        root.right = construct(nums, mid + 1, right);
        return root;
    }
}
